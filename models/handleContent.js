const uuid = require('uuid/v4');
const promise = require('bluebird');

const options = {
  // Initialization Options
  promiseLib: promise
};

const pgp = require('pg-promise')(options);
const connectionString = 'postgres://localhost:5432/audio_practice';
const db = pgp(connectionString);

const addNewContent = async (audioName, path_to_audio, transcriptTokens) => {
  // SAVE THE AUDIO TO original_audio
  // save req.file.path (which is generated by multer?) to path_to
  // save the name
  // generate the uuid using uuid() and save this to a const... then use it ad the id

  // SAVE TRANSCRIPT TOKENS to phrase
  // use the const generated above for original_audio_id
  // loop through and assign each an ordinal_in_original
  // leave clip_id null
  // save token as the text
  const original_audio_id = uuid();
  await db.none(
    `insert into original_audio(id, name, path_to, snippet) values('${original_audio_id}', '${audioName}', '${path_to_audio}', '${transcriptTokens[0]}')`
  );
  await Promise.all(
    transcriptTokens.map(async (token, ordinalValue) => {
      await db.none(
        `insert into phrase(original_audio_id, ordinal_in_original, text) values('${original_audio_id}', '${ordinalValue}', '${token}')`
      );
    }),
  );
};

const getContentPreviews = async () => {
  const originalAudioRecords = await db.any(`select * from original_audio`);
  return originalAudioRecords.map(record => ({ id: record.id, name: record.name, snippet: record.snippet }));
};

const getContentByAudioId = async id => {
  // get the record for the original_audio
  // get the file from its path_to
  // select from phrases by original_audio_id
  // return all that
  const audioRecord = await db.any(`select * from original_audio where id='${id}'`);
  const { name, path_to_audio } = audioRecord[0];
  let phrases = null;
  await db.any(`select * from phrase where original_audio_id='${id}'`).then(phraseRecords => {
    phrases = phraseRecords;
    phrases.sort((phrase1, phrase2) => {
      if (phrase1.ordinal_in_original === phrase2.oridinal_in_original) {
        return 0;
      }
      return phrase1.ordinal_in_original > phrase2.oridinal_in_original ? 1 : -1;
    });
  });
  return { name, path_to_audio, phrases,  };
};

module.exports = { addNewContent, getContentPreviews, getContentById: getContentByAudioId };